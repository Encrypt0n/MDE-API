name: Flaky Test Detector

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  run-tests-multiple-times:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        run: [1, 2, 3, 4, 5]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.x'

      - name: Restore dependencies
        run: dotnet restore

      - name: Run tests with coverage and trx log (Run ${{ matrix.run }})
        run: >
          dotnet test
          --logger "trx;LogFileName=TestResults_${{ matrix.run }}.trx"
          /p:CollectCoverage=true
          /p:CoverletOutputFormat=cobertura
          /p:CoverletOutput=./TestResults/Coverage_${{ matrix.run }}

      - name: Upload test results and coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-run-${{ matrix.run }}
          path: |
            **/TestResults/TestResults_${{ matrix.run }}.trx
            **/TestResults/Coverage_${{ matrix.run }}.cobertura.xml

  summarize-results:
    runs-on: ubuntu-latest
    needs: run-tests-multiple-times
    steps:
      - name: Download all test artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts

      - name: List all .trx files
        run: find ./artifacts -name "*.trx"

      - name: Install trx2junit
        run: dotnet tool install --global trx2junit

      - name: Convert .trx to .xml
        run: |
          for file in $(find ./artifacts -name "*.trx"); do
            trx2junit "$file"
          done

      - name: Print flaky test summary in log
        run: |
          echo "### Flaky Test Run Summary"
          totalRuns=0
          totalFailures=0
          for file in $(find . -name "TestResults_*.xml"); do
            runName=$(basename "$file" .xml)
            failures=$(grep -o "<failure>" "$file" | wc -l)
            echo "- $runName: $failures failures"
            totalRuns=$((totalRuns+1))
            totalFailures=$((totalFailures+failures))
          done
          echo "- Total Runs: $totalRuns"
          echo "- Total Failures: $totalFailures"

  check-coverage-against-public-methods:
    runs-on: ubuntu-latest
    needs: run-tests-multiple-times
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.x'

      - name: Build for reflection
        run: dotnet build MDE_API/MDE_API.csproj -c Release

      - name: Download coverage files
        uses: actions/download-artifact@v4
        with:
          path: coverage

      - name: Create checker app
        run: |
          dotnet new console -o CoverageChecker
          dotnet add CoverageChecker package System.Reflection.MetadataLoadContext
          cat > CoverageChecker/Program.cs <<'EOF'
          using System;
          using System.IO;
          using System.Linq;
          using System.Reflection;
          using System.Collections.Generic;
          using System.Runtime.Loader;
          using System.Xml.Linq;
          using System.Reflection.Metadata;
          using System.Reflection.PortableExecutable;
          using System.Runtime.InteropServices;
          
          class Program
          {
              static void Main()
              {
                  var apiDllPath = Path.GetFullPath("MDE_API/bin/Release/net8.0/MDE_API.dll");
          
                  if (!File.Exists(apiDllPath))
                  {
                      Console.WriteLine($"‚ùå Could not find: {apiDllPath}");
                      Environment.Exit(1);
                  }
          
                  // Grab all assemblies needed from the shared runtime
                  var runtimeDir = Path.GetDirectoryName(typeof(object).Assembly.Location)!;
                  var runtimeAssemblies = Directory.GetFiles(runtimeDir, "*.dll");
          
                  // Add project assemblies
                  var projectAssemblies = Directory.GetFiles(Path.GetDirectoryName(apiDllPath)!, "*.dll");
          
                  var resolver = new PathAssemblyResolver(runtimeAssemblies.Concat(projectAssemblies));
                  using var mlc = new MetadataLoadContext(resolver);
          
                  var assembly = mlc.LoadFromAssemblyPath(apiDllPath);
          
                  var publicMethods = assembly.GetTypes()
                      .Where(t => t.IsPublic && t.IsClass && !t.IsAbstract && !t.IsGenericType)
                      .SelectMany(t => t.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly))
                      .Where(m => !m.IsSpecialName)
                      .Select(m => $"{m.DeclaringType.FullName}.{m.Name}")
                      .ToHashSet();
          
                  Console.WriteLine($"‚úÖ Found {publicMethods.Count} public methods.");
          
                  var coveredMethods = new HashSet<string>();
          
                  foreach (var file in Directory.GetFiles("coverage", "Coverage_*.cobertura.xml", SearchOption.AllDirectories))
                  {
                      var doc = XDocument.Load(file);
                      var methods = doc.Descendants("method");
          
                      foreach (var m in methods)
                      {
                          var className = m.Parent?.Parent?.Attribute("name")?.Value;
                          var methodName = m.Attribute("name")?.Value;
                          var linesCovered = m.Elements("lines").Elements("line").Any(l => l.Attribute("hits")?.Value != "0");
          
                          if (!string.IsNullOrWhiteSpace(className) && !string.IsNullOrWhiteSpace(methodName) && linesCovered)
                          {
                              coveredMethods.Add($"{className}.{methodName}");
                          }
                      }
                  }
          
                  var uncovered = publicMethods.Except(coveredMethods).ToList();
          
                  Console.WriteLine("\n=== üß™ Public Method Coverage Report ===");
          
                  foreach (var method in publicMethods.OrderBy(m => m))
                  {
                      if (coveredMethods.Contains(method))
                          Console.WriteLine($"‚úÖ {method}");
                      else
                          Console.WriteLine($"‚ùå {method}");
                  }
          
                  Console.WriteLine($"\nTotal: {publicMethods.Count}, Covered: {coveredMethods.Count}, Missing: {uncovered.Count}");
          
                  if (uncovered.Count > 0)
                  {
                      Console.WriteLine("\n‚ùå The following public methods have no test coverage:");
                      foreach (var m in uncovered)
                          Console.WriteLine(" - " + m);
                      Environment.Exit(1);
                  }
                  else
                  {
                      Console.WriteLine("üéâ All public methods are covered by tests!");
                  }
              }
          }

          EOF

      - name: Build and run checker
        run: |
          dotnet build CoverageChecker
          dotnet run --project CoverageChecker
